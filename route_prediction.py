# -*- coding: utf-8 -*-
"""route_prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w_pzuHkeTBbkeGillXT6gHaX97JznPKV
"""

pip install requests pandas googlemaps osmnx folium

import googlemaps
import pandas as pd
import time
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tf.keras import layers
import osmnx as ox
import networkx as nx
import folium
import numpy as np
import matplotlib.pyplot as plt
from google.colab import drive
drive.mount('/content/gdrive')

def fetch_route_osmnx(origin_coords, destination_coords, travel_mode="walk"):
    """
    Fetches a route between origin and destination coordinates using OSMnx.

    Args:
        origin_coords (tuple): (latitude, longitude) of the origin.
        destination_coords (tuple): (latitude, longitude) of the destination.
        travel_mode (str): Mode of travel. Options: "walk", "bike", "drive".

    Returns:
        list: List of (latitude, longitude) tuples representing the route.
    """
    # Get the graph for the specified travel mode
    mode_to_network_type = {
        "walk": "walk",
        "bike": "bike",
        "drive": "drive",
    }
    network_type = mode_to_network_type.get(travel_mode, "walk")

    # Load the graph around the origin
    G = ox.graph_from_point(origin_coords, dist=2000, network_type=network_type)

    # Find the nearest nodes to the origin and destination
    origin_node = ox.distance.nearest_nodes(G, origin_coords[1], origin_coords[0])
    destination_node = ox.distance.nearest_nodes(G, destination_coords[1], destination_coords[0])

    # Calculate the shortest path
    route = nx.shortest_path(G, origin_node, destination_node, weight="length")

    # Get the coordinates of the route
    route_coords = [(G.nodes[node]['y'], G.nodes[node]['x']) for node in route]
    return route_coords

def process_route_data(route_coords):
    """
    Converts route coordinates into a Pandas DataFrame.

    Args:
        route_coords (list): List of (latitude, longitude) tuples.

    Returns:
        pd.DataFrame: Tabular representation of route steps.
    """
    # Create DataFrame from route coordinates
    route_df = pd.DataFrame(route_coords, columns=["latitude", "longitude"])
    return route_df

# Define origin and destination coordinates
origin = (40.748817, -73.985428)  # Example: Empire State Building
destination = (40.730610, -73.935242)  # Example: Astoria Park

# Fetch and process the route
route_coords = fetch_route_osmnx(origin, destination, travel_mode="walk")
route_df = process_route_data(route_coords)

print(route_df.head())  # Display the first few rows of the route

# Save to CSV for future use
route_df.to_csv("route_data_osmnx.csv", index=False)

def plot_route_on_map(route_coords):
    """
    Plot the route on a map using Folium.

    Args:
        route_coords (list): List of (latitude, longitude) tuples.
    """
    # Create a map centered at the midpoint of the route
    mid_idx = len(route_coords) // 2
    route_map = folium.Map(location=route_coords[mid_idx], zoom_start=14)

    # Add the route to the map
    folium.PolyLine(route_coords, color="blue", weight=5).add_to(route_map)

    # Mark start and end points
    folium.Marker(route_coords[0], popup="Start", icon=folium.Icon(color="green")).add_to(route_map)
    folium.Marker(route_coords[-1], popup="End", icon=folium.Icon(color="red")).add_to(route_map)

    return route_map

route_map = plot_route_on_map(route_coords)
route_map.save("route_map_osmnx.html")
print("Route map saved as route_map_osmnx.html.")

def generate_route_instructions(route_coords, G):
    """
    Generates basic textual instructions for a route based on OSMnx graph.

    Args:
        route_coords (list): List of (latitude, longitude) tuples.
        G (networkx.MultiDiGraph): OSMnx graph.

    Returns:
        list: List of textual instructions for the route.
    """
    instructions = []
    for i in range(len(route_coords) - 1):
        # Get the current and next nodes
        current_node = ox.distance.nearest_nodes(G, route_coords[i][1], route_coords[i][0])
        next_node = ox.distance.nearest_nodes(G, route_coords[i + 1][1], route_coords[i + 1][0])

        # Get edge data between the current and next node
        edge_data = G.get_edge_data(current_node, next_node, default={})

        # Extract street name or set to "Unknown"
        street_name = edge_data.get(0, {}).get("name", "Unknown")

        # Approximate an instruction
        instruction = f"Go towards {street_name}" if street_name else "Continue straight"
        instructions.append(instruction)
    return instructions

# Define origin and destination coordinates
origin = (40.748817, -73.985428)  # Example: Empire State Building
destination = (40.730610, -73.935242)  # Example: Astoria Park

# Fetch route using OSMnx
travel_mode = "walk"
G = ox.graph_from_point(origin, dist=2000, network_type=travel_mode)
origin_node = ox.distance.nearest_nodes(G, origin[1], origin[0])
destination_node = ox.distance.nearest_nodes(G, destination[1], destination[0])
route = nx.shortest_path(G, origin_node, destination_node, weight="length")
route_coords = [(G.nodes[node]['y'], G.nodes[node]['x']) for node in route]

# Generate instructions
instructions = generate_route_instructions(route_coords, G)

# Create a DataFrame
route_df = pd.DataFrame({
    "start_location": route_coords[:-1],
    "end_location": route_coords[1:],
    "instruction": instructions,
    "distance": [nx.shortest_path_length(G, route[i], route[i+1], weight="length") for i in range(len(route) - 1)],
    "duration": [0.02 * nx.shortest_path_length(G, route[i], route[i+1], weight="length") for i in range(len(route) - 1)],  # Assuming average walking speed
})

# Encode text instructions as numerical data
label_encoder = LabelEncoder()
route_df['instruction_encoded'] = label_encoder.fit_transform(route_df['instruction'])

# Features: Encoded instructions, distance, and duration
X = route_df[['instruction_encoded', 'distance', 'duration']].values

# Labels: Predict next end location (latitude, longitude)
y = route_df['end_location'].apply(lambda loc: (loc[0], loc[1])).tolist()

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print("Training features (X_train):", X_train.shape)
print("Training labels (y_train):", len(y_train))

# Convert y_train and y_test to NumPy arrays
y_train = np.array(y_train)
y_test = np.array(y_test)

# Define a simple feedforward neural network
model = tf.keras.Sequential([
    layers.Dense(512, activation='relu', input_shape=(X_train.shape[1],)),
    layers.Dropout(0.3),  # Add dropout to prevent overfitting
    layers.Dense(256, activation='relu'),
    layers.BatchNormalization(),  # Normalize layer outputs
    layers.Dense(128, activation='relu'),
    layers.Dense(2)  # Predict latitude and longitude
])

early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

model.compile(optimizer='adam', loss='mse', metrics=['mae'])
model.summary()

# Train the model
history = model.fit(
    X_train, y_train,
    validation_split = 0.2,
    epochs=500,
    batch_size=32,
    callbacks=[early_stopping]
)

# Evaluate the model
loss, mae = model.evaluate(X_test, y_test)
print(f"Test Loss: {loss}, Test MAE: {mae}")

# Plot locations
train_lats, train_lngs = zip(*y_train)
test_lats, test_lngs = zip(*y_test)

plt.scatter(train_lngs, train_lats, color='blue', label='Train Data', alpha=0.5)
plt.scatter(test_lngs, test_lats, color='orange', label='Test Data', alpha=0.5)
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.legend()
plt.title('Spatial Distribution of Locations')
plt.show()

# Predict the next stop
sample_input = X_test[:5]  # Select a few examples
predictions = model.predict(sample_input)

print("Predicted End Locations (Lat, Lng):", predictions)
print("True End Locations:", y_test[:5])

model.save('/content/gdrive/My Drive/Colab Notebooks/Capstone/model.h5')

model.export('saved_model')

pip install tensorflowjs

#!tensorflowjs_converter --input_format keras new_model.h5 ./output_model
!tensorflowjs_converter --input_format=tf_saved_model saved_model neural_network_model_tfjs --skip_op_check
!zip -r model_json_baru.zip neural_network_model_tfjs